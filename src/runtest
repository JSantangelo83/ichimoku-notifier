#!/usr/bin/python3
#Imports
import sys
from analyzer import *


#TODO: Sequencial charge of candles

def getKlines(interval,symbol,nklines):
    lastcandle = json.loads(requests.get(f'https://api1.binance.com/api/v3/klines?symbol={symbol}&interval={interval}&limit=1').content.decode())[0]    
    duration = lastcandle[6] - lastcandle[0]

    if nklines <= 1000:
        return json.loads(requests.get(f'https://api1.binance.com/api/v3/klines?symbol={symbol}&interval={interval}&limit={nklines}').content.decode())    
    else:
        ret = []
        while nklines > 1000:
            ret += json.loads(requests.get(f'https://api1.binance.com/api/v3/klines?symbol={symbol}&interval={interval}&limit={1000}&startTime={lastcandle[0] - (duration * nklines)}').content.decode())
            nklines -= 1000
        ret += json.loads(requests.get(f'https://api1.binance.com/api/v3/klines?symbol={symbol}&interval={interval}&limit={nklines}').content.decode())
        return ret
                                    
def main():
    #Params
    interval = sys.argv[1]
    symbol = sys.argv[2]        
    strategyname = sys.argv[3]
    nklines = int(sys.argv[4])

    #the strategy minimum candles
    limit = 200
    #initial values
    trade = None        
    signaldisplayed = False
    # Get n candles from binance
    rawCandles=getKlines(interval,symbol,nklines)
    
    #Test strategy until finds a trade 
    x = limit
    while (x < len(rawCandles)):
        ts = [candle[0] for candle in rawCandles][:x]#[-limit:]
        op = [candle[1] for candle in rawCandles][:x]#[-limit:]
        high = [candle[2] for candle in rawCandles][:x]#[-limit:]
        low = [candle[3] for candle in rawCandles][:x]#[-limit:]
        close = [candle[4] for candle in rawCandles][:x]#[-limit:]
        vol = [candle[5] for candle in rawCandles][:x]#[-limit:]

        formatedCandles = {'timestamp': ts, 'open': op, 'high': high, 'low': low, 'close': close, 'volume': vol}

        reqdf = pandas.DataFrame(formatedCandles)
        
        reqdf.to_csv('../tmp/request.csv', encoding='utf-8')
        reqdf = pandas.read_csv('../tmp/request.csv', sep=',')

        strategydf = eval(f"{strategyname}Calculate(reqdf)")
        
        #Only search for trades if there isnt any
        if trade == None: 
            trade = eval(f'{strategyname}Analyze(strategydf,2)')
            signaldisplayed = False
        
        x += 1
                
        #graph it
        #Show the graphic
        if(trade != None and signaldisplayed==False):
            plt, fig, ax = plotDefaults(reqdf, f'{symbol} {interval}')
            eval(f'{strategyname}Plot(strategydf, plt, fig, ax, trade)')
            plt.legend()
            plt.show()
            signaldisplayed=True
        elif(trade != None and signaldisplayed == True):
            print(f'Direction:{trade["direction"]}\nTP: {trade["takeprofit"]}\nSL:{trade["stoploss"]}\nPrice:{strategydf.close.iloc[-1]}')
            #If it goes into TP or SL start searching another trade
            if ((trade['direction'] == 'long') and ((strategydf.close.iloc[-1] > trade['takeprofit']) or (strategydf.close.iloc[-1] < trade['stoploss']))) or ((trade['direction'] == 'short') and ((strategydf.close.iloc[-1] < trade['takeprofit']) or (strategydf.close.iloc[-1] > trade['stoploss']))): 
                plt, fig, ax = plotDefaults(reqdf, f'{symbol} {interval}')
                eval(f'{strategyname}Plot(strategydf, plt, fig, ax, trade)')
                plt.legend()
                plt.show()
                trade = None
                signaldisplayed = False
                

if __name__ == '__main__':
    main()

